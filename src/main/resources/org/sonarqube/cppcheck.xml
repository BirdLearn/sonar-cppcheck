<results version="2">
<errors>
<error id="AssignmentAddressToInteger" msg="Assigning a pointer to an integer is not portable. (since Cppcheck 1.52)" verbose="Assigning a pointer to an integer (int/long/etc) is not portable across different platforms and compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux they are of different width. In worst case you end up assigning 64-bit address to 32-bit integer. The safe way is to store addresses only in pointer types (or typedefs like uintptr_t)." />
<error id="AssignmentIntegerToAddress" msg="Assigning an integer to a pointer is not portable. (since Cppcheck 1.52)" verbose="Assigning an integer (int/long/etc) to a pointer is not portable across different platforms and compilers. For example in 32-bit Windows and linux they are same width, but in 64-bit Windows and linux they are of different width. In worst case you end up assigning 64-bit integer to 32-bit pointer. The safe way is to store addresses only in pointer types (or typedefs like uintptr_t)." />
<error id="CastAddressToIntegerAtReturn" msg="Returning an address value in a function with integer return type is not portable. (since Cppcheck 1.55)" verbose="Returning an address value in a function with integer (int/long/etc) return type is not portable across different platforms and compilers. For example in 32-bit Windows and Linux they are same width, but in 64-bit Windows and Linux they are of different width. In worst case you end up casting 64-bit address down to 32-bit integer. The safe way is to always return an integer." />
<error id="CastIntegerToAddressAtReturn" msg="Returning an integer in a function with pointer return type is not portable. (since Cppcheck 1.55)" verbose="Returning an integer (int/long/etc) in a function with pointer return type is not portable across different platforms and compilers. For example in 32-bit Windows and Linux they are same width, but in 64-bit Windows and Linux they are of different width. In worst case you end up casting 64-bit integer down to 32-bit pointer. The safe way is to always return a pointer." />
<error id="ConfigurationNotChecked" msg="Skipping configuration &apos;X&apos; since the value of &apos;X&apos; is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. (since Cppcheck 1.56)" verbose="Skipping configuration &apos;X&apos; since the value of &apos;X&apos; is unknown. Use -D if you want to check it. You can use -U to skip it explicitly." />
<error id="IOWithoutPositioning" msg="Read and write operations without a call to a positioning function (fseek, fsetpos or rewind) or fflush in between result in undefined behaviour. (since Cppcheck 1.55)" verbose="Read and write operations without a call to a positioning function (fseek, fsetpos or rewind) or fflush in between result in undefined behaviour." />
<error id="StlMissingComparison" msg="Missing bounds check for extra iterator increment in loop. (since Cppcheck 1.57)" verbose="The iterator incrementing is suspicious - it is incremented at line  and then at line . The loop might unintentionally skip an element in the container. There is no comparison between these increments to prevent that the iterator is incremented beyond the end." />
<error id="argumentSize" msg="The array &apos;array&apos; is too small, the function &apos;function&apos; expects a bigger one. (since Cppcheck 1.58)" verbose="The array &apos;array&apos; is too small, the function &apos;function&apos; expects a bigger one." />
<error id="arithOperationsOnVoidPointer" msg="&apos;varname&apos; is of type &apos;vartype&apos;. When using void pointers in calculations, the behaviour is undefined. (since Cppcheck 1.61)" verbose="&apos;varname&apos; is of type &apos;vartype&apos;. When using void pointers in calculations, the behaviour is undefined. Arithmetic operations on &apos;void *&apos; is a GNU C extension, which defines the &apos;sizeof(void)&apos; to be 1." />
<error id="arrayIndexOutOfBounds" msg="Array &apos;array[2]&apos; index array[1][1] out of bounds. (since Cppcheck 1.52)" verbose="Array &apos;array[2]&apos; index array[1][1] out of bounds." />
<error id="arrayIndexOutOfBoundsCond" msg="Array &apos;x[10]&apos; accessed at index 20, which is out of bounds. Otherwise condition &apos;y==20&apos; is redundant. (since Cppcheck 1.66)" verbose="Array &apos;x[10]&apos; accessed at index 20, which is out of bounds. Otherwise condition &apos;y==20&apos; is redundant." />
<error id="arrayIndexThenCheck" msg="Array index &apos;index&apos; is used before limits check. (since Cppcheck 1.52)" verbose="Defensive programming: The variable &apos;index&apos; is used as an array index before it is checked that is within limits. This can mean that the array might be accessed out of bounds. Reorder conditions such as &apos;(a[i] &amp;&amp; i &lt; 10)&apos; to &apos;(i &lt; 10 &amp;&amp; a[i])&apos;. That way the array will not be accessed if the index is out of limits." />
<error id="assertWithSideEffect" msg="Assert statement calls a function which may have desired side effects: &apos;function&apos;. (since Cppcheck 1.63)" verbose="Non-pure function: &apos;function&apos; is called inside assert statement. Assert statements are removed from release builds so the code inside assert statement is not executed. If the code is needed also in release builds, this is a bug." />
<error id="assignBoolToFloat" msg="Boolean value assigned to floating point variable. (Cppcheck 1.66)" verbose="Boolean value assigned to floating point variable." />
<error id="assignBoolToPointer" msg="Boolean value assigned to pointer. (since Cppcheck 1.52)" verbose="Boolean value assigned to pointer." />
<error id="assignIfError" msg="Mismatching assignment and comparison, comparison &apos;&apos; is always false. (since Cppcheck 1.52)" verbose="Mismatching assignment and comparison, comparison &apos;&apos; is always false." />
<error id="assignmentInAssert" msg="Assert statement modifies &apos;var&apos;. (since Cppcheck 1.52)" verbose="Variable &apos;var&apos; is modified insert assert statement. Assert statements are removed from release builds so the code inside assert statement is not executed. If the code is needed also in release builds, this is a bug." />
<error id="autoVariables" msg="Address of local auto-variable assigned to a function parameter. (since Cppcheck 1.52)" verbose="Dangerous assignment - the function parameter is assigned the address of a local auto-variable. Local auto-variables are reserved from the stack which is freed when the function ends. So the pointer to a local variable is invalid after the function ends." />
<error id="autovarInvalidDeallocation" msg="Deallocation of an auto-variable results in undefined behaviour. (since Cppcheck 1.52)" verbose="The deallocation of an auto-variable results in undefined behaviour. You should only free memory that has been allocated dynamically." />
<error id="badBitmaskCheck" msg="Result of operator &apos;|&apos; is always true if one operand is non-zero. Did you intend to use &apos;&amp;&apos;? (since Cppcheck 1.69)" verbose="Result of operator &apos;|&apos; is always true if one operand is non-zero. Did you intend to use &apos;&amp;&apos;?" />
<error SonarQube="S872"
    id="bitwiseOnBoolean" msg="Boolean variable &apos;varname&apos; is used in bitwise operation. Did you mean &apos;&amp;&amp;&apos;? (since Cppcheck 1.54)" verbose="Boolean variable &apos;varname&apos; is used in bitwise operation. Did you mean &apos;&amp;&amp;&apos;?" />
<error id="boostForeachError" msg="BOOST_FOREACH caches the end() iterator. It&apos;s undefined behavior if you modify the container inside. (since Cppcheck 1.52)" verbose="BOOST_FOREACH caches the end() iterator. It&apos;s undefined behavior if you modify the container inside." />
<error id="bufferAccessOutOfBounds" msg="Buffer is accessed out of bounds: buffer (since Cppcheck 1.52)" verbose="Buffer is accessed out of bounds: buffer" />
<error id="bufferNotZeroTerminated" msg="The buffer &apos;buffer&apos; is not null-terminated after the call to strncpy(). (since Cppcheck 1.54)" verbose="The buffer &apos;buffer&apos; is not null-terminated after the call to strncpy(). This will cause bugs later in the code if the code assumes the buffer is null-terminated." />
<error SonarQube="S1044"
    id="catchExceptionByValue" msg="Exception should be caught by reference. (since Cppcheck 1.52)" verbose="The exception is caught by value. It could be caught as a (const) reference which is usually recommended in C++." />
<error id="charArrayIndex" msg="Signed &apos;char&apos; type used as array index. (since Cppcheck 1.52)" verbose="Signed &apos;char&apos; type used as array index. If the value can be greater than 127 there will be a buffer underflow because of sign extension." />
<error id="charBitOp" msg="When using &apos;char&apos; variables in bit operations, sign extension can generate unexpected results. (since Cppcheck 1.52)" verbose="When using &apos;char&apos; variables in bit operations, sign extension can generate unexpected results. For example:\012    char c = 0x80;\012    int i = 0 | c;\012    if (i &amp; 0x8000)\012        printf(&quot;not expected&quot;);\012The &quot;not expected&quot; will be printed on the screen." />
<error id="charLiteralWithCharPtrCompare" msg="Char literal compared with pointer &apos;foo&apos;. Did you intend to dereference it? (since Cppcheck 1.66)" verbose="Char literal compared with pointer &apos;foo&apos;. Did you intend to dereference it?" />
<error id="checkCastIntToCharAndBack" msg="Storing func_name() return value in char variable and then comparing with EOF. (since Cppcheck 1.59)" verbose="When saving func_name() return value in char variable there is loss of precision.  When func_name() returns EOF this value is truncated. Comparing the char variable with EOF can have unexpected results. For instance a loop &quot;while (EOF != (c = func_name());&quot; loops forever on some compilers/platforms and on other compilers/platforms it will stop when the file contains a matching character." />
<error SonarQube="S864"
    id="clarifyCalculation" msg="Clarify calculation precedence for &apos;+&apos; and &apos;?&apos;. (since Cppcheck 1.52)" verbose="Suspicious calculation. Please use parentheses to clarify the code. The code &apos;&apos;a+b?c:d&apos;&apos; should be written as either &apos;&apos;(a+b)?c:d&apos;&apos; or &apos;&apos;a+(b?c:d)&apos;&apos;." />
<error SonarQube="S864"
    id="clarifyCondition" msg="Suspicious condition (assignment + comparison); Clarify expression with parentheses. (since Cppcheck 1.52)" verbose="Suspicious condition (assignment + comparison); Clarify expression with parentheses." />
<error id="clarifyStatement" msg="Ineffective statement similar to &apos;*A++;&apos;. Did you intend to write &apos;(*A)++;&apos;? (since Cppcheck 1.56)" verbose="A statement like &apos;*A++;&apos; might not do what you intended. Postfix &apos;operator++&apos; is executed before &apos;operator*&apos;. Thus, the dereference is meaningless. Did you intend to write &apos;(*A)++;&apos;?" />
<error SonarQube="S878"
    id="commaSeparatedReturn" msg="Comma is used in return statement. The comma can easily be misread as a &apos;;&apos;. (since Cppcheck 1.61)" verbose="Comma is used in return statement. When comma is used in a return statement it can easily be misread as a semicolon. For example in the code below the value of &apos;b&apos; is returned if the condition is true, but it is easy to think that &apos;a+1&apos; is returned:\012    if (x)\012        return a + 1,\012    b++;\012However it can be useful to use comma in macros. Cppcheck does not warn when such a macro is then used in a return statement, it is less likely such code is misunderstood." />
<error id="compareBoolExpressionWithInt" msg="Comparison of a boolean expression with an integer other than 0 or 1. (since Cppcheck 1.52)" verbose="Comparison of a boolean expression with an integer other than 0 or 1." />
<error id="comparisonError" msg="Expression &apos;(X &amp; 0x6) == 0x1&apos; is always false. (since Cppcheck 1.52)" verbose="The expression &apos;(X &amp; 0x6) == 0x1&apos; is always false. Check carefully constants and operators used, these errors might be hard to spot sometimes. In case of complex expression it might help to split it to separate expressions." />
<error id="comparisonFunctionIsAlwaysTrueOrFalse" msg="Comparison of two identical variables with isless(varName,varName) always evaluates to false. (since Cppcheck 1.62)" verbose="The function isless is designed to compare two variables. Calling this function with one variable (varName) for both parameters leads to a statement which is always false." />
<error SonarQube="S872"
    id="comparisonOfBoolWithBoolError" msg="Comparison of a variable having boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator. (since Cppcheck 1.57)" verbose="The variable &apos;var_name&apos; is of type &apos;bool&apos; and comparing &apos;bool&apos; value using relational (&lt;, &gt;, &lt;= or &gt;=) operator could cause unexpected results." />
<error id="comparisonOfBoolWithInt" msg="Comparison of a boolean with an integer that is neither 1 nor 0. (since Cppcheck 1.52)" verbose="The expression &apos;varname&apos; is of type &apos;bool&apos; and it is compared against an integer value that is neither 1 nor 0." />
<error SonarQube="S872"
    id="comparisonOfFuncReturningBoolError" msg="Comparison of a function returning boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator. (since Cppcheck 1.57)" verbose="The return type of function &apos;func_name&apos; is &apos;bool&apos; and result is of type &apos;bool&apos;. Comparing &apos;bool&apos; value using relational (&lt;, &gt;, &lt;= or &gt;=) operator could cause unexpected results." />
<error SonarQube="S872"
    id="comparisonOfTwoFuncsReturningBoolError" msg="Comparison of two functions returning boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator. (since Cppcheck 1.57)" verbose="The return type of function &apos;func_name1&apos; and function &apos;func_name2&apos; is &apos;bool&apos; and result is of type &apos;bool&apos;. Comparing &apos;bool&apos; value using relational (&lt;, &gt;, &lt;= or &gt;=) operator could cause unexpected results." />
<error SonarQube="S905"
    id="constStatement" msg="Redundant code: Found a statement that begins with type constant. (since Cppcheck 1.52)" verbose="Redundant code: Found a statement that begins with type constant." />
<error id="copyCtorPointerCopying" msg="Value of pointer &apos;var&apos;, which points to allocated memory, is copied in copy constructor instead of allocating new memory. (since Cppcheck 1.57)" verbose="Value of pointer &apos;var&apos;, which points to allocated memory, is copied in copy constructor instead of allocating new memory." />
<error SonarQube="S106:cpp"
    id="coutCerrMisusage" msg="Invalid usage of output stream: &apos;&lt;&lt; std::cout&apos;. (since Cppcheck 1.52)" verbose="Invalid usage of output stream: &apos;&lt;&lt; std::cout&apos;." />
<error id="cppcheckError" msg="Analysis failed. If the code is valid then please report this failure. (Cppcheck 1.52-1.64)" verbose="Analysis failed. If the code is valid then please report this failure." />
<error SonarQube="S871"
    id="cstyleCast" msg="C-style pointer casting (since Cppcheck 1.52)" verbose="C-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts." />
<error id="dangerousUsageStrtol" msg="Invalid radix in call to strtol(). It must be 0 or 2-36. (Cppcheck 1.52-1.62)" verbose="Invalid radix in call to strtol(). It must be 0 or 2-36." />
<error id="deadpointer" msg="Dead pointer usage. Pointer &apos;pointer&apos; is dead if it has been assigned &apos;&amp;x&apos; at line 0. (since Cppcheck 1.67)" verbose="Dead pointer usage. Pointer &apos;pointer&apos; is dead if it has been assigned &apos;&amp;x&apos; at line 0." />
<error id="deallocDealloc" msg="Deallocating a deallocated pointer: varname (since Cppcheck 1.52)" verbose="Deallocating a deallocated pointer: varname" />
<error id="deallocret" msg="Returning/dereferencing &apos;p&apos; after it is deallocated / released (since Cppcheck 1.55)" verbose="Returning/dereferencing &apos;p&apos; after it is deallocated / released" />
<error id="deallocuse" msg="Dereferencing &apos;varname&apos; after it is deallocated / released (since Cppcheck 1.52)" verbose="Dereferencing &apos;varname&apos; after it is deallocated / released" />
<error id="derefInvalidIterator" msg="Possible dereference of an invalid iterator: i (since Cppcheck 1.60)" verbose="Make sure to check that the iterator is valid before dereferencing it - not after." />
<error id="divideSizeof" msg="Division of result of sizeof() on pointer type. (since Cppcheck 1.58)" verbose="Division of result of sizeof() on pointer type. sizeof() returns the size of the pointer, not the size of the memory area it points to." />
<error id="doubleFree" msg="Memory pointed to by &apos;varname&apos; is freed twice. (since Cppcheck 1.53)" verbose="Memory pointed to by &apos;varname&apos; is freed twice." />
<error SonarQube="S2387"
    id="duplInheritedMember" msg="The class &apos;class&apos; defines member variable with name &apos;variable&apos; also defined in its parent class &apos;class&apos;. (since Cppcheck 1.62)" verbose="The class &apos;class&apos; defines member variable with name &apos;variable&apos; also defined in its parent class &apos;class&apos;." />
<error SonarQube="S1871"
    id="duplicateBranch" msg="Found duplicate branches for &apos;if&apos; and &apos;else&apos;. (since Cppcheck 1.53)" verbose="Finding the same code in an &apos;if&apos; and related &apos;else&apos; branch is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct." />
<error SonarQube="S1763"
    id="duplicateBreak" msg="Consecutive return, break, continue, goto or throw statements are unnecessary. (since Cppcheck 1.52)" verbose="Consecutive return, break, continue, goto or throw statements are unnecessary. The second statement can never be executed, and so should be removed." />
<error SonarQube="S1764"
    id="duplicateExpression" msg="Same expression on both sides of &apos;&amp;&amp;&apos;. (since Cppcheck 1.52)" verbose="Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct." />
<error SonarQube="S1871"
    id="duplicateExpressionTernary" msg="Same expression in both branches of ternary operator. (since Cppcheck 1.69)" verbose="Finding the same expression in both branches of ternary operator is suspicious as the same code is executed regardless of the condition." />
<error SonarQube="S1862"
    id="duplicateIf" msg="Duplicate conditions in &apos;if&apos; and related &apos;else if&apos;. (Cppcheck 1.52-1.64)" verbose="Duplicate conditions in &apos;if&apos; and related &apos;else if&apos;. This is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct." />
<error id="erase" msg="Dangerous iterator usage after erase()-method. (Cppcheck 1.52-1.56)" verbose="The iterator is invalid after it has been used in erase() function. Dereferencing or comparing it with another iterator is invalid operation." />
<error id="eraseDereference" msg="Invalid iterator &apos;iter&apos; used. (since Cppcheck 1.52)" verbose="The iterator &apos;iter&apos; is invalid before being assigned. Dereferencing or comparing it with another iterator is invalid operation." />
<error id="exceptDeallocThrow" msg="Exception thrown in invalid state, &apos;p&apos; points at deallocated memory. (since Cppcheck 1.52)" verbose="Exception thrown in invalid state, &apos;p&apos; points at deallocated memory." />
<error id="exceptRethrowCopy" msg="Throwing a copy of the caught exception instead of rethrowing the original exception. (since Cppcheck 1.52)" verbose="Rethrowing an exception with &apos;throw varname;&apos; creates an unnecessary copy of &apos;varname&apos;. To rethrow the caught exception without unnecessary copying or slicing, use a bare &apos;throw;&apos;." />
<error id="exceptThrowInAttributeNoThrowFunction" msg="Exception thrown in __attribute__((nothrow)) function. (Cppcheck 1.65-1.68)" verbose="Exception thrown in __attribute__((nothrow)) function." />
<error id="exceptThrowInDeclspecNoThrowFunction" msg="Exception thrown in __declspec(nothrow) function. (Cppcheck 1.65-1.68)" verbose="Exception thrown in __declspec(nothrow) function." />
<error SonarQube="ExceptionInDestructor"
    id="exceptThrowInDestructor" msg="Class Class is not safe, destructor throws exception (since Cppcheck 1.52)" verbose="The class Class is not safe because its destructor throws an exception. If Class is used and an exception is thrown that is caught in an outer scope the program will terminate." />
<error id="exceptThrowInNoThrowFunction" msg="Exception thrown in throw() function. (Cppcheck 1.65-1.68)" verbose="Exception thrown in throw() function." />
<error id="exceptThrowInNoexecptFunction" msg="Exception thrown in noexcept function. (Cppcheck 1.65-1.68)" verbose="Exception thrown in noexcept function." />
<error id="fflushOnInputStream" msg="fflush() called on input stream &apos;stdin&apos; may result in undefined behaviour on non-linux systems. (since Cppcheck 1.52)" verbose="fflush() called on input stream &apos;stdin&apos; may result in undefined behaviour on non-linux systems." />
<error id="functionConst" msg="Technically the member function &apos;class::function&apos; can be const. (since Cppcheck 1.54)" verbose="The member function &apos;class::function&apos; can be made a const function. Making this function &apos;const&apos; should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state?" />
<error id="functionStatic" msg="Technically the member function &apos;class::function&apos; can be static. (since Cppcheck 1.56)" verbose="The member function &apos;class::function&apos; can be made a static function. Making a function static can bring a performance benefit since no &apos;this&apos; instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances?" />
<error id="ignoredReturnValue" msg="Return value of function malloc() is not used. (since Cppcheck 1.67)" verbose="Return value of function malloc() is not used." />
<error id="incompleteArrayFill" msg="Array &apos;buffer&apos; is filled incompletely. Did you forget to multiply the size given to &apos;memset()&apos; with &apos;sizeof(*buffer)&apos;? (since Cppcheck 1.56)" verbose="The array &apos;buffer&apos; is filled incompletely. The function &apos;memset()&apos; needs the size given in bytes, but an element of the given array is larger than one byte. Did you forget to multiply the size with &apos;sizeof(*buffer)&apos;?" />
<error id="incorrectLogicOperator" msg="Logical disjunction always evaluates to true: foo &gt; 3 &amp;&amp; foo &lt; 4. (since Cppcheck 1.52)" verbose="Logical disjunction always evaluates to true: foo &gt; 3 &amp;&amp; foo &lt; 4. Are these conditions necessary? Did you intend to use &amp;&amp; instead? Are the numbers correct? Are you comparing the correct variables?" />
<error id="incorrectStringBooleanError" msg="Conversion of string literal &quot;Hello World&quot; to bool always evaluates to true. (since Cppcheck 1.52)" verbose="Conversion of string literal &quot;Hello World&quot; to bool always evaluates to true." />
<error id="incorrectStringCompare" msg="String literal &quot;Hello World&quot; doesn&apos;t match length argument for substr(). (since Cppcheck 1.52)" verbose="String literal &quot;Hello World&quot; doesn&apos;t match length argument for substr()." />
<error SonarQube="S2668"
    id="incrementboolean" msg="Incrementing a variable of type &apos;bool&apos; with postfix operator++ is deprecated by the C++ Standard. You should assign it the value &apos;true&apos; instead. (since Cppcheck 1.52)" verbose="The operand of a postfix increment operator may be of type bool but it is deprecated by C++ Standard (Annex D-1) and the operand is always set to true. You should assign it the value &apos;true&apos; instead." />
<error SonarQube="S3229:cpp"
    id="initializerList" msg="Member variable &apos;class::variable&apos; is in the wrong place in the initializer list. (since Cppcheck 1.52)" verbose="Member variable &apos;class::variable&apos; is in the wrong place in the initializer list. Members are initialized in the order they are declared, not in the order they are in the initializer list.  Keeping the initializer list in the same order that the members were declared prevents order dependent initialization errors." />
<error id="insecureCmdLineArgs" msg="Buffer overrun possible for long command line arguments. (since Cppcheck 1.52)" verbose="Buffer overrun possible for long command line arguments." />
<error id="integerOverflow" msg="Signed integer overflow for expression &apos;&apos; (since Cppcheck 1.67)" verbose="Signed integer overflow for expression &apos;&apos;" />
<error id="invalidFunctionArg" msg="Invalid func_name() argument nr 1 (since Cppcheck 1.63)" verbose="Invalid func_name() argument nr 1" />
<error id="invalidFunctionArgBool" msg="Invalid func_name() argument nr 1. A non-boolean value is required. (since Cppcheck 1.63)" verbose="Invalid func_name() argument nr 1. A non-boolean value is required." />
<error id="invalidIterator1" msg="Invalid iterator: iterator (since Cppcheck 1.52)" verbose="Invalid iterator: iterator" />
<error id="invalidIterator2" msg="After push_back|push_front|insert(), the iterator &apos;iterator&apos; may be invalid. (since Cppcheck 1.52)" verbose="After push_back|push_front|insert(), the iterator &apos;iterator&apos; may be invalid." />
<error id="invalidLengthModifierError" msg="&apos;I&apos; in format string (no. 1) is a length modifier and cannot be used without a conversion specifier. (since Cppcheck 1.69)" verbose="&apos;I&apos; in format string (no. 1) is a length modifier and cannot be used without a conversion specifier." />
<error id="invalidPointer" msg="Invalid pointer &apos;pointer&apos; after push_back(). (since Cppcheck 1.52)" verbose="Invalid pointer &apos;pointer&apos; after push_back()." />
<error id="invalidPointerCast" msg="Casting between float* and double* which have an incompatible binary data representation. (since Cppcheck 1.54)" verbose="Casting between float* and double* which have an incompatible binary data representation." />
<error id="invalidPrintfArgType_float" msg="%f in format string (no. 1) requires &apos;double&apos; but the argument type is Unknown. (since Cppcheck 1.53)" verbose="%f in format string (no. 1) requires &apos;double&apos; but the argument type is Unknown." />
<error id="invalidPrintfArgType_int" msg="%X in format string (no. 1) requires &apos;unsigned int&apos; but the argument type is Unknown. (since Cppcheck 1.53)" verbose="%X in format string (no. 1) requires &apos;unsigned int&apos; but the argument type is Unknown." />
<error id="invalidPrintfArgType_n" msg="%n in format string (no. 1) requires &apos;int *&apos; but the argument type is Unknown. (since Cppcheck 1.53)" verbose="%n in format string (no. 1) requires &apos;int *&apos; but the argument type is Unknown." />
<error id="invalidPrintfArgType_p" msg="%p in format string (no. 1) requires an address but the argument type is Unknown. (since Cppcheck 1.53)" verbose="%p in format string (no. 1) requires an address but the argument type is Unknown." />
<error id="invalidPrintfArgType_s" msg="%s in format string (no. 1) requires &apos;char *&apos; but the argument type is Unknown. (since Cppcheck 1.53)" verbose="%s in format string (no. 1) requires &apos;char *&apos; but the argument type is Unknown." />
<error id="invalidPrintfArgType_sint" msg="%i in format string (no. 1) requires &apos;int&apos; but the argument type is Unknown. (since Cppcheck 1.56)" verbose="%i in format string (no. 1) requires &apos;int&apos; but the argument type is Unknown." />
<error id="invalidPrintfArgType_uint" msg="%u in format string (no. 1) requires &apos;unsigned int&apos; but the argument type is Unknown. (since Cppcheck 1.56)" verbose="%u in format string (no. 1) requires &apos;unsigned int&apos; but the argument type is Unknown." />
<error id="invalidScanfArgType" msg="scanf argument no. 1: requires a non-const pointer or array as argument. (Cppcheck 1.53-1.61)" verbose="scanf argument no. 1: requires a non-const pointer or array as argument." />
<error id="invalidScanfArgType_float" msg="%f in format string (no. 1) requires &apos;float *&apos; but the argument type is Unknown. (since Cppcheck 1.62)" verbose="%f in format string (no. 1) requires &apos;float *&apos; but the argument type is Unknown." />
<error id="invalidScanfArgType_int" msg="%d in format string (no. 1) requires &apos;int *&apos; but the argument type is Unknown. (since Cppcheck 1.62)" verbose="%d in format string (no. 1) requires &apos;int *&apos; but the argument type is Unknown." />
<error id="invalidScanfArgType_s" msg="%s in format string (no. 1) requires a &apos;char *&apos; but the argument type is Unknown. (since Cppcheck 1.62)" verbose="%s in format string (no. 1) requires a &apos;char *&apos; but the argument type is Unknown." />
<error id="invalidScanfFormatWidth" msg="Width 5 given in format string (no. 10) is larger than destination buffer &apos;[0]&apos;, use %-1s to prevent overflowing it. (since Cppcheck 1.55)" verbose="Width 5 given in format string (no. 10) is larger than destination buffer &apos;[0]&apos;, use %-1s to prevent overflowing it." />
<error SonarQube="S1079"
    id="invalidscanf" msg="scanf without field width limits can crash with huge input data. (since Cppcheck 1.52)" verbose="scanf without field width limits can crash with huge input data. Add a field width specifier to fix this problem:\012    %s =&gt; %20s\012\012Sample program that can crash:\012\012#include &lt;stdio.h&gt;\012int main()\012{\012    char c[5];\012    scanf(&quot;%s&quot;, c);\012    return 0;\012}\012\012Typing in 5 or more characters may make the program crash. The correct usage here is &apos;scanf(&quot;%4s&quot;, c);&apos;, as the maximum field width does not include the terminating null byte.\012Source: http://linux.die.net/man/3/scanf\012Source: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c" />
<error id="invalidscanf_libc" msg="scanf without field width limits can crash with huge input data on some versions of libc. (Cppcheck 1.67-1.69)" verbose="scanf without field width limits can crash with huge input data on libc versions older than 2.13-25. Add a field width specifier to fix this problem:\012    %i =&gt; %3i\012\012Sample program that can crash:\012\012#include &lt;stdio.h&gt;\012int main()\012{\012    int a;\012    scanf(&quot;%i&quot;, &amp;a);\012    return 0;\012}\012\012To make it crash:\012perl -e &apos;print &quot;5&quot;x2100000&apos; | ./a.out" />
<error id="iterators" msg="Same iterator is used with different containers &apos;container1&apos; and &apos;container2&apos;. (since Cppcheck 1.52)" verbose="Same iterator is used with different containers &apos;container1&apos; and &apos;container2&apos;." />
<error id="knownConditionTrueFalse" msg="Condition &apos;x&apos; is always true (since Cppcheck 1.70)" verbose="Condition &apos;x&apos; is always true" />
<error id="leakNoVarFunctionCall" msg="Allocation with funcName, funcName doesn&apos;t release it. (since Cppcheck 1.54)" verbose="Allocation with funcName, funcName doesn&apos;t release it." />
<error id="leakReturnValNotUsed" msg="Return value of allocation function &apos;funcName&apos; is not stored. (since Cppcheck 1.63)" verbose="Return value of allocation function &apos;funcName&apos; is not stored." />
<error id="leakUnsafeArgAlloc" msg="Unsafe allocation. If funcName() throws, memory could be leaked. Use make_shared&lt;int&gt;() instead. (since Cppcheck 1.69)" verbose="Unsafe allocation. If funcName() throws, memory could be leaked. Use make_shared&lt;int&gt;() instead." />
<error id="literalWithCharPtrCompare" msg="String literal compared with variable &apos;foo&apos;. Did you intend to use strcmp() instead? (since Cppcheck 1.56)" verbose="String literal compared with variable &apos;foo&apos;. Did you intend to use strcmp() instead?" />
<error id="mallocOnClassError" msg="Memory for class instance allocated with malloc(), but class contains a std::string. (since Cppcheck 1.59)" verbose="Memory for class instance allocated with malloc(), but class a std::string. This is unsafe, since no constructor is called and class members remain uninitialized. Consider using &apos;new&apos; instead." />
<error id="mallocOnClassWarning" msg="Memory for class instance allocated with malloc(), but class provides constructors. (since Cppcheck 1.59)" verbose="Memory for class instance allocated with malloc(), but class provides constructors. This is unsafe, since no constructor is called and class members remain uninitialized. Consider using &apos;new&apos; instead." />
<error id="memleak" msg="Memory leak: varname (since Cppcheck 1.52)" verbose="Memory leak: varname" />
<error id="memleakOnRealloc" msg="Common realloc mistake: &apos;varname&apos; nulled but not freed upon failure (since Cppcheck 1.52)" verbose="Common realloc mistake: &apos;varname&apos; nulled but not freed upon failure" />
<error id="memsetClass" msg="Using &apos;memfunc&apos; on class that contains a classname. (since Cppcheck 1.52)" verbose="Using &apos;memfunc&apos; on class that contains a classname is unsafe, because constructor, destructor and copy operator calls are omitted. These are necessary for this non-POD type to ensure that a valid object is created." />
<error id="memsetClassFloat" msg="Using memset() on class which contains a floating point number. (since Cppcheck 1.67)" verbose="Using memset() on class which contains a floating point number. This is not portable because memset() sets each byte of a block of memory to a specific value and the actual representation of a floating-point value is implementation defined. Note: In case of an IEEE754-1985 compatible implementation setting all bits to zero results in the value 0.0." />
<error id="memsetClassReference" msg="Using &apos;memfunc&apos; on class that contains a reference. (since Cppcheck 1.67)" verbose="Using &apos;memfunc&apos; on class that contains a reference." />
<error id="memsetFloat" msg="The 2nd memset() argument &apos;varname&apos; is a float, its representation is implementation defined. (since Cppcheck 1.64)" verbose="The 2nd memset() argument &apos;varname&apos; is a float, its representation is implementation defined. memset() is used to set each byte of a block of memory to a specific value and the actual representation of a floating-point value is implementation defined." />
<error id="memsetValueOutOfRange" msg="The 2nd memset() argument &apos;varname&apos; doesn&apos;t fit into an &apos;unsigned char&apos;. (since Cppcheck 1.64)" verbose="The 2nd memset() argument &apos;varname&apos; doesn&apos;t fit into an &apos;unsigned char&apos;. The 2nd parameter is passed as an &apos;int&apos;, but the function fills the block of memory using the &apos;unsigned char&apos; conversion of this value." />
<error id="memsetZeroBytes" msg="memset() called to fill 0 bytes of &apos;varname&apos;. (since Cppcheck 1.52)" verbose="memset() called to fill 0 bytes of &apos;varname&apos;. The second and third arguments might be inverted. The function memset ( void * ptr, int value, size_t num ) sets the first num bytes of the block of memory pointed by ptr to the specified value." />
<error id="mismatchAllocDealloc" msg="Mismatching allocation and deallocation: varname (since Cppcheck 1.52)" verbose="Mismatching allocation and deallocation: varname" />
<error id="mismatchSize" msg="The allocated size sz is not a multiple of the underlying type&apos;s size. (since Cppcheck 1.52)" verbose="The allocated size sz is not a multiple of the underlying type&apos;s size." />
<error id="mismatchingBitAnd" msg="Mismatching bitmasks. Result is always 0 (X = Y &amp; 0xf0; Z = X &amp; 0x1; =&gt; Z=0). (since Cppcheck 1.59)" verbose="Mismatching bitmasks. Result is always 0 (X = Y &amp; 0xf0; Z = X &amp; 0x1; =&gt; Z=0)." />
<error id="mismatchingContainers" msg="Iterators of different containers are used together. (since Cppcheck 1.52)" verbose="Iterators of different containers are used together." />
<error id="missingInclude" msg="Include file: &quot;&quot; not found. (since Cppcheck 1.52)" verbose="Include file: &quot;&quot; not found." />
<error id="missingIncludeSystem" msg="Include file: &lt;&gt; not found. Please note: Cppcheck does not need standard library headers to get proper results. (since Cppcheck 1.59)" verbose="Include file: &lt;&gt; not found. Please note: Cppcheck does not need standard library headers to get proper results." />
<error SonarQube="S1079"
    id="missingScanfFormatWidth" msg="scanf %s in format string (no. 1) does not specify a width (Cppcheck 1.55)" verbose="scanf %s in format string (no. 1) does not specify a width" />
<error id="moduloAlwaysTrueFalse" msg="Comparison of modulo result is predetermined, because it is always less than 1. (since Cppcheck 1.55)" verbose="Comparison of modulo result is predetermined, because it is always less than 1." />
<error SonarQube="S1862"
    id="multiCondition" msg="Expression is always false because &apos;else if&apos; condition matches previous condition at line 1. (since Cppcheck 1.52)" verbose="Expression is always false because &apos;else if&apos; condition matches previous condition at line 1." />
<error id="multiplySizeof" msg="Multiplying sizeof() with sizeof() indicates a logic error. (since Cppcheck 1.58)" verbose="Multiplying sizeof() with sizeof() indicates a logic error." />
<error id="nanInArithmeticExpression" msg="Using NaN/Inf in a computation. (since Cppcheck 1.61)" verbose="Using NaN/Inf in a computation. Although nothing bad really happens, it is suspicious." />
<error id="negativeArraySize" msg="Declaration of array &apos;&apos; with negative size is undefined behaviour (since Cppcheck 1.70)" verbose="Declaration of array &apos;&apos; with negative size is undefined behaviour" />
<error id="negativeIndex" msg="Array index -1 is out of bounds. (since Cppcheck 1.52)" verbose="Array index -1 is out of bounds." />
<error id="negativeMemoryAllocationSize" msg="Memory allocation size is negative. (since Cppcheck 1.64)" verbose="Memory allocation size is negative.Negative allocation size has no specified behaviour." />
<error id="noConstructor" msg="The class &apos;classname&apos; does not have a constructor. (since Cppcheck 1.52)" verbose="The class &apos;classname&apos; does not have a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior." />
<error id="noCopyConstructor" msg="&apos;class class&apos; does not have a copy constructor which is recommended since the class contains a pointer to allocated memory. (since Cppcheck 1.57)" verbose="&apos;class class&apos; does not have a copy constructor which is recommended since the class contains a pointer to allocated memory." />
<error SonarQube="S1709:cpp"
    id="noExplicitConstructor" msg="Class &apos;classname&apos; has a constructor with 1 argument that is not explicit. (since Cppcheck 1.69)" verbose="Class &apos;classname&apos; has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided." />
<error id="noExplicitCopyMoveConstructor" msg="Abstract class &apos;classname&apos; has a copy/move constructor that is not explicit. (Cppcheck 1.69-1.70)" verbose="Abstract class &apos;classname&apos; has a copy/move constructor that is not explicit. For abstract classes, even copy/move constructors may be declared explicit, as, by definition, abstract classes cannot be instantiated, and so objects of such type should never be passed by value." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsasctime" msg="Found non reentrant function &apos;asctime&apos;. For threadsafe applications it is recommended to use the reentrant replacement function &apos;asctime_r&apos; (Cppcheck 1.52)" verbose="Found non reentrant function &apos;asctime&apos;. For threadsafe applications it is recommended to use the reentrant replacement function &apos;asctime_r&apos;" />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionscrypt" msg="Non reentrant function &apos;crypt&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;crypt_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;crypt&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;crypt_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsctermid" msg="Non reentrant function &apos;ctermid&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;ctermid_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;ctermid&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;ctermid_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsctime" msg="Found non reentrant function &apos;ctime&apos;. For threadsafe applications it is recommended to use the reentrant replacement function &apos;ctime_r&apos; (Cppcheck 1.52)" verbose="Found non reentrant function &apos;ctime&apos;. For threadsafe applications it is recommended to use the reentrant replacement function &apos;ctime_r&apos;" />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsecvt" msg="Non reentrant function &apos;ecvt&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;ecvt_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;ecvt&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;ecvt_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsfcvt" msg="Non reentrant function &apos;fcvt&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;fcvt_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;fcvt&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;fcvt_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsfgetgrent" msg="Non reentrant function &apos;fgetgrent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;fgetgrent_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;fgetgrent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;fgetgrent_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsfgetpwent" msg="Non reentrant function &apos;fgetpwent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;fgetpwent_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;fgetpwent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;fgetpwent_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsfgetspent" msg="Non reentrant function &apos;fgetspent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;fgetspent_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;fgetspent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;fgetspent_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgcvt" msg="Non reentrant function &apos;gcvt&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;gcvt_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;gcvt&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;gcvt_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetgrent" msg="Non reentrant function &apos;getgrent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getgrent_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getgrent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getgrent_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetgrgid" msg="Non reentrant function &apos;getgrgid&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getgrgid_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getgrgid&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getgrgid_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetgrnam" msg="Non reentrant function &apos;getgrnam&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getgrnam_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getgrnam&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getgrnam_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgethostbyaddr" msg="Non reentrant function &apos;gethostbyaddr&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;gethostbyaddr_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;gethostbyaddr&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;gethostbyaddr_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgethostbyname" msg="Non reentrant function &apos;gethostbyname&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;gethostbyname_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;gethostbyname&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;gethostbyname_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgethostbyname2" msg="Non reentrant function &apos;gethostbyname2&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;gethostbyname2_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;gethostbyname2&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;gethostbyname2_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgethostent" msg="Non reentrant function &apos;gethostent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;gethostent_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;gethostent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;gethostent_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetlogin" msg="Non reentrant function &apos;getlogin&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getlogin_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getlogin&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getlogin_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetnetbyaddr" msg="Non reentrant function &apos;getnetbyaddr&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getnetbyaddr_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getnetbyaddr&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getnetbyaddr_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetnetbyname" msg="Non reentrant function &apos;getnetbyname&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getnetbyname_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getnetbyname&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getnetbyname_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetnetgrent" msg="Non reentrant function &apos;getnetgrent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getnetgrent_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getnetgrent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getnetgrent_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetprotobyname" msg="Non reentrant function &apos;getprotobyname&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getprotobyname_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getprotobyname&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getprotobyname_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetpwent" msg="Non reentrant function &apos;getpwent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getpwent_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getpwent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getpwent_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetpwnam" msg="Non reentrant function &apos;getpwnam&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getpwnam_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getpwnam&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getpwnam_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetpwuid" msg="Non reentrant function &apos;getpwuid&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getpwuid_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getpwuid&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getpwuid_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetrpcbyname" msg="Non reentrant function &apos;getrpcbyname&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getrpcbyname_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getrpcbyname&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getrpcbyname_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetrpcbynumber" msg="Non reentrant function &apos;getrpcbynumber&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getrpcbynumber_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getrpcbynumber&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getrpcbynumber_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetrpcent" msg="Non reentrant function &apos;getrpcent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getrpcent_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getrpcent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getrpcent_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetservbyname" msg="Non reentrant function &apos;getservbyname&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getservbyname_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getservbyname&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getservbyname_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetservbyport" msg="Non reentrant function &apos;getservbyport&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getservbyport_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getservbyport&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getservbyport_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetservent" msg="Non reentrant function &apos;getservent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getservent_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getservent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getservent_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetspent" msg="Non reentrant function &apos;getspent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getspent_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getspent&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getspent_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgetspnam" msg="Non reentrant function &apos;getspnam&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getspnam_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;getspnam&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;getspnam_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsgmtime" msg="Non reentrant function &apos;gmtime&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;gmtime_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;gmtime&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;gmtime_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionslocaltime" msg="Non reentrant function &apos;localtime&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;localtime_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;localtime&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;localtime_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsrand" msg="Found non reentrant function &apos;rand&apos;. For threadsafe applications it is recommended to use the reentrant replacement function &apos;rand_r&apos; (Cppcheck 1.52)" verbose="Found non reentrant function &apos;rand&apos;. For threadsafe applications it is recommended to use the reentrant replacement function &apos;rand_r&apos;" />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsreaddir" msg="Non reentrant function &apos;readdir&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;readdir_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;readdir&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;readdir_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsstrtok" msg="Non reentrant function &apos;strtok&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;strtok_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;strtok&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;strtok_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionstempnam" msg="Non reentrant function &apos;tempnam&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;tempnam_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;tempnam&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;tempnam_r&apos;." />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionstmpnam" msg="Found non reentrant function &apos;tmpnam&apos;. For threadsafe applications it is recommended to use the reentrant replacement function &apos;tmpnam_r&apos; (Cppcheck 1.52)" verbose="Found non reentrant function &apos;tmpnam&apos;. For threadsafe applications it is recommended to use the reentrant replacement function &apos;tmpnam_r&apos;" />
<error SonarQube="NonReentrantFunction"
    id="nonreentrantFunctionsttyname" msg="Non reentrant function &apos;ttyname&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;ttyname_r&apos;. (since Cppcheck 1.52)" verbose="Non reentrant function &apos;ttyname&apos; called. For threadsafe applications it is recommended to use the reentrant replacement function &apos;ttyname_r&apos;." />
<error id="nullPointer" msg="Null pointer dereference (since Cppcheck 1.52)" verbose="Null pointer dereference" />
<error id="nullPointerDefaultArg" msg="Possible null pointer dereference if the default parameter value is used: pointer (since Cppcheck 1.70)" verbose="Possible null pointer dereference if the default parameter value is used: pointer" />
<error id="nullPointerRedundantCheck" msg="Either the condition is redundant or there is possible null pointer dereference: pointer. (since Cppcheck 1.70)" verbose="Either the condition is redundant or there is possible null pointer dereference: pointer." />
<error id="obsoleteFunctionsalloca" msg="Obsolete function &apos;alloca&apos; called. In C99 and later it is recommended to use a variable length array instead. (since Cppcheck 1.70)" verbose="The obsolete function &apos;alloca&apos; is called. In C99 and later it is recommended to use a variable length array or a dynamically allocated array instead. The function &apos;alloca&apos; is dangerous for many reasons (http://stackoverflow.com/questions/1018853/why-is-alloca-not-considered-good-practice and http://linux.die.net/man/3/alloca)." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsasctime" msg="Obsolete function &apos;asctime&apos; called. It is recommended to use the function &apos;strftime&apos; instead. (since Cppcheck 1.53)" verbose="Obsolete function &apos;asctime&apos; called. It is recommended to use the function &apos;strftime&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsasctime_r" msg="Obsolete function &apos;asctime_r&apos; called. It is recommended to use the function &apos;strftime&apos; instead. (since Cppcheck 1.53)" verbose="Obsolete function &apos;asctime_r&apos; called. It is recommended to use the function &apos;strftime&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsbcmp" msg="Obsolete function &apos;bcmp&apos; called. It is recommended to use the function &apos;memcmp&apos; instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;bcmp&apos; called. It is recommended to use the function &apos;memcmp&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsbcopy" msg="Obsolete function &apos;bcopy&apos; called. It is recommended to use the &apos;memmove&apos; or &apos;memcpy&apos; function instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;bcopy&apos; called. It is recommended to use the &apos;memmove&apos; or &apos;memcpy&apos; function instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsbsd_signal" msg="Obsolete function &apos;bsd_signal&apos; called. It is recommended to use the function &apos;sigaction&apos; instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;bsd_signal&apos; called. It is recommended to use the function &apos;sigaction&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsbzero" msg="Obsolete function &apos;bzero&apos; called. It is recommended to use the function &apos;memset&apos; instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;bzero&apos; called. It is recommended to use the function &apos;memset&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsctime" msg="Found obsolete function &apos;ctime&apos;. It is recommended to use the function &apos;strftime&apos; instead (Cppcheck 1.53-1.55)" verbose="Found obsolete function &apos;ctime&apos;. It is recommended to use the function &apos;strftime&apos; instead" />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsctime_r" msg="Obsolete function &apos;ctime_r&apos; called. It is recommended to use the function &apos;strftime&apos; instead. (since Cppcheck 1.56)" verbose="Obsolete function &apos;ctime_r&apos; called. It is recommended to use the function &apos;strftime&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsecvt" msg="Obsolete function &apos;ecvt&apos; called. It is recommended to use the function &apos;sprintf&apos; instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;ecvt&apos; called. It is recommended to use the function &apos;sprintf&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsfcvt" msg="Obsolete function &apos;fcvt&apos; called. It is recommended to use the function &apos;sprintf&apos; instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;fcvt&apos; called. It is recommended to use the function &apos;sprintf&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsftime" msg="Obsolete function &apos;ftime&apos; called. It is recommended to use time(), gettimeofday() or clock_gettime() instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;ftime&apos; called. It is recommended to use time(), gettimeofday() or clock_gettime() instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsgcvt" msg="Obsolete function &apos;gcvt&apos; called. It is recommended to use the function &apos;sprintf&apos; instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;gcvt&apos; called. It is recommended to use the function &apos;sprintf&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsgetcontext" msg="Obsolete function &apos;getcontext&apos; called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads. (since Cppcheck 1.52)" verbose="Obsolete function &apos;getcontext&apos; called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsgethostbyaddr" msg="Obsolete function &apos;gethostbyaddr&apos; called. It is recommended to use the function &apos;getnameinfo&apos; instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;gethostbyaddr&apos; called. It is recommended to use the function &apos;getnameinfo&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsgethostbyname" msg="Obsolete function &apos;gethostbyname&apos; called. It is recommended to use the function &apos;getaddrinfo&apos; instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;gethostbyname&apos; called. It is recommended to use the function &apos;getaddrinfo&apos; instead." />
<error id="obsoleteFunctionsgets" msg="Obsolete function &apos;gets&apos; called. It is recommended to use the function &apos;fgets&apos; instead. (since Cppcheck 1.70)" verbose="The obsolete function &apos;gets&apos; is called. With &apos;gets&apos; you&apos;ll get a buffer overrun if the input data exceeds the size of the buffer. It is recommended to use the function &apos;fgets&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsgetwd" msg="Obsolete function &apos;getwd&apos; called. It is recommended to use the function &apos;getcwd&apos; instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;getwd&apos; called. It is recommended to use the function &apos;getcwd&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsindex" msg="Obsolete function &apos;index&apos; called. It is recommended to use the function &apos;strchr&apos; instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;index&apos; called. It is recommended to use the function &apos;strchr&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsmakecontext" msg="Obsolete function &apos;makecontext&apos; called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads. (since Cppcheck 1.52)" verbose="Obsolete function &apos;makecontext&apos; called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionspthread_attr_getstackaddr" msg="Obsolete function &apos;pthread_attr_getstackaddr&apos; called. It is recommended to use the function &apos;pthread_attr_getstack&apos; instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;pthread_attr_getstackaddr&apos; called. It is recommended to use the function &apos;pthread_attr_getstack&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionspthread_attr_setstackaddr" msg="Obsolete function &apos;pthread_attr_setstackaddr&apos; called. It is recommended to use the function &apos;pthread_attr_setstack&apos; instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;pthread_attr_setstackaddr&apos; called. It is recommended to use the function &apos;pthread_attr_setstack&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsrand_r" msg="Obsolete function &apos;rand_r&apos; called. It is recommended to use the function &apos;rand&apos; instead. (since Cppcheck 1.53)" verbose="Obsolete function &apos;rand_r&apos; called. It is recommended to use the function &apos;rand&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsrindex" msg="Obsolete function &apos;rindex&apos; called. It is recommended to use the function &apos;strrchr&apos; instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;rindex&apos; called. It is recommended to use the function &apos;strrchr&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsscalbln" msg="Obsolete function &apos;scalb&apos; called. It is recommended to use &apos;scalbln&apos;, &apos;scalblnf&apos; or &apos;scalblnl&apos; instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;scalb&apos; called. It is recommended to use &apos;scalbln&apos;, &apos;scalblnf&apos; or &apos;scalblnl&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsswapcontext" msg="Obsolete function &apos;swapcontext&apos; called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads. (since Cppcheck 1.52)" verbose="Obsolete function &apos;swapcontext&apos; called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionstmpnam" msg="Obsolete function &apos;tmpnam&apos; called. It is recommended to use &apos;tmpfile&apos;, &apos;mkstemp&apos; or &apos;mkdtemp&apos; instead. (since Cppcheck 1.53)" verbose="Obsolete function &apos;tmpnam&apos; called. It is recommended to use &apos;tmpfile&apos;, &apos;mkstemp&apos; or &apos;mkdtemp&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionstmpnam_r" msg="Obsolete function &apos;tmpnam_r&apos; called. It is recommended to use &apos;tmpfile&apos;, &apos;mkstemp&apos; or &apos;mkdtemp&apos; instead. (since Cppcheck 1.53)" verbose="Obsolete function &apos;tmpnam_r&apos; called. It is recommended to use &apos;tmpfile&apos;, &apos;mkstemp&apos; or &apos;mkdtemp&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsualarm" msg="Obsolete function &apos;ualarm&apos; called. It is recommended to use &apos;timer_create&apos;, &apos;timer_delete&apos;, &apos;timer_getoverrun&apos;, &apos;timer_gettime&apos; or &apos;timer_settime&apos; instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;ualarm&apos; called. It is recommended to use &apos;timer_create&apos;, &apos;timer_delete&apos;, &apos;timer_getoverrun&apos;, &apos;timer_gettime&apos; or &apos;timer_settime&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsusleep" msg="Obsolete function &apos;usleep&apos; called. It is recommended to use the &apos;nanosleep&apos; or &apos;setitimer&apos; function instead. (since Cppcheck 1.52)" verbose="The obsolete function &apos;usleep&apos; is called. POSIX.1-2001 declares usleep() function obsolete and POSIX.1-2008 removes it. It is recommended that new applications use the &apos;nanosleep&apos; or &apos;setitimer&apos; function." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsutime" msg="Obsolete function &apos;utime&apos; called. It is recommended to use the function &apos;utimensat&apos; instead. (since Cppcheck 1.53)" verbose="Obsolete function &apos;utime&apos; called. It is recommended to use the function &apos;utimensat&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionsvfork" msg="Obsolete function &apos;vfork&apos; called. It is recommended to use the function &apos;fork&apos; instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;vfork&apos; called. It is recommended to use the function &apos;fork&apos; instead." />
<error SonarQube="ObsoletePosixFunction"
    id="obsoleteFunctionswcswcs" msg="Obsolete function &apos;wcswcs&apos; called. It is recommended to use the function &apos;wcsstr&apos; instead. (since Cppcheck 1.52)" verbose="Obsolete function &apos;wcswcs&apos; called. It is recommended to use the function &apos;wcsstr&apos; instead." />
<error id="operatorEq" msg="&apos;class::operator=&apos; should return &apos;class &amp;&apos;. (since Cppcheck 1.53)" verbose="The class::operator= does not conform to standard C/C++ behaviour. To conform to standard C/C++ behaviour, return a reference to self (such as: &apos;class &amp;class::operator=(..) { .. return *this; }&apos;. For safety reasons it might be better to not fix this message. If you think that safety is always more important than conformance then please ignore/suppress this message. For more details about this topic, see the book &quot;Effective C++&quot; by Scott Meyers." />
<error id="operatorEqMissingReturnStatement" msg="No &apos;return&apos; statement in non-void function causes undefined behavior. (since Cppcheck 1.69)" verbose="No &apos;return&apos; statement in non-void function causes undefined behavior." />
<error SonarQube="S1236"
    id="operatorEqRetRefThis" msg="&apos;operator=&apos; should return reference to &apos;this&apos; instance. (since Cppcheck 1.52)" verbose="&apos;operator=&apos; should return reference to &apos;this&apos; instance." />
<error id="operatorEqShouldBeLeftUnimplemented" msg="&apos;operator=&apos; should either return reference to &apos;this&apos; instance or be declared private and left unimplemented. (since Cppcheck 1.69)" verbose="&apos;operator=&apos; should either return reference to &apos;this&apos; instance or be declared private and left unimplemented." />
<error SonarQube="S1250"
    id="operatorEqToSelf" msg="&apos;operator=&apos; should check for assignment to self to avoid problems with dynamic memory. (since Cppcheck 1.52)" verbose="&apos;operator=&apos; should check for assignment to self to ensure that each block of dynamically allocated memory is owned and managed by only one instance of the class." />
<error id="operatorEqVarError" msg="Member variable &apos;classname::&apos; is not assigned a value in &apos;classname::operator=&apos;. (since Cppcheck 1.52)" verbose="Member variable &apos;classname::&apos; is not assigned a value in &apos;classname::operator=&apos;." />
<error id="oppositeInnerCondition" msg="Opposite conditions in nested &apos;if&apos; blocks lead to a dead code block. (since Cppcheck 1.57)" verbose="Opposite conditions in nested &apos;if&apos; blocks lead to a dead code block." />
<error id="outOfBounds" msg="index is out of bounds: Supplied size 2 is larger than actual size 1. (since Cppcheck 1.52)" verbose="index is out of bounds: Supplied size 2 is larger than actual size 1." />
<error id="passedByValue" msg="Function parameter &apos;parametername&apos; should be passed by reference. (since Cppcheck 1.52)" verbose="Parameter &apos;parametername&apos; is passed by value. It could be passed as a (const) reference which is usually faster and recommended in C++." />
<error id="pointerArithBool" msg="Converting pointer arithmetic result to bool. The bool is always true unless there is undefined behaviour. (since Cppcheck 1.63)" verbose="Converting pointer arithmetic result to bool. The boolean result is always true unless there is pointer arithmetic overflow, and overflow is undefined behaviour. Probably a dereference is forgotten." />
<error id="pointerLessThanZero" msg="A pointer can not be negative so it is either pointless or an error to check if it is. (since Cppcheck 1.56)" verbose="A pointer can not be negative so it is either pointless or an error to check if it is." />
<error id="pointerOutOfBounds" msg="Undefined behaviour, pointer arithmetic &apos;&apos; is out of bounds. (since Cppcheck 1.52)" verbose="Undefined behaviour, pointer arithmetic &apos;&apos; is out of bounds. From chapter 6.5.6 in the C specification:\012&quot;When an expression that has integer type is added to or subtracted from a pointer, ..&quot; and then &quot;If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.&quot;" />
<error id="pointerPositive" msg="A pointer can not be negative so it is either pointless or an error to check if it is not. (since Cppcheck 1.56)" verbose="A pointer can not be negative so it is either pointless or an error to check if it is not." />
<error id="pointerSize" msg="Size of pointer &apos;varname&apos; used instead of size of its data. (since Cppcheck 1.54)" verbose="Size of pointer &apos;varname&apos; used instead of size of its data. This is likely to lead to a buffer overflow. You probably intend to write &apos;sizeof(*varname)&apos;." />
<error id="possibleBufferAccessOutOfBounds" msg="Possible buffer overflow if strlen(source) is larger than or equal to sizeof(destination). (since Cppcheck 1.52)" verbose="Possible buffer overflow if strlen(source) is larger than or equal to sizeof(destination). The source buffer is larger than the destination buffer so there is the potential for overflowing the destination buffer." />
<error id="possibleReadlinkBufferOverrun" msg="readlink() might return the full size of &apos;buffer&apos;. Lower the supplied size by one. (Cppcheck 1.54-1.68)" verbose="readlink() might return the full size of &apos;buffer&apos;. If a buffer[len] = &apos;\0&apos;; statement follows, it will overrun the buffer. Lower the supplied size by one." />
<error SonarQube="S1705"
    id="postfixOperator" msg="Prefer prefix ++/-- operators for non-primitive types. (since Cppcheck 1.52)" verbose="Prefix ++/-- operators should be preferred for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code." />
<error SonarQube="PPErrorDirectiveReached"
    id="preprocessorErrorDirective" msg="#error message (since Cppcheck 1.52)" verbose="#error message" />
<error id="publicAllocationError" msg="Possible leak in public function. The pointer &apos;varname&apos; is not deallocated before it is allocated. (since Cppcheck 1.57)" verbose="Possible leak in public function. The pointer &apos;varname&apos; is not deallocated before it is allocated." />
<error id="raceAfterInterlockedDecrement" msg="Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead. (since Cppcheck 1.70)" verbose="Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead." />
<error id="readWriteOnlyFile" msg="Read operation on a file that was opened only for writing. (since Cppcheck 1.55)" verbose="Read operation on a file that was opened only for writing." />
<error id="reademptycontainer" msg="Reading from empty STL container &apos;var&apos; (since Cppcheck 1.65)" verbose="Reading from empty STL container &apos;var&apos;" />
<error id="redundantAssignInSwitch" msg="Variable &apos;var&apos; is reassigned a value before the old one has been used. &apos;break;&apos; missing? (since Cppcheck 1.52)" verbose="Variable &apos;var&apos; is reassigned a value before the old one has been used. &apos;break;&apos; missing?" />
<error id="redundantAssignment" msg="Variable &apos;var&apos; is reassigned a value before the old one has been used. (since Cppcheck 1.57)" verbose="Variable &apos;var&apos; is reassigned a value before the old one has been used." />
<error id="redundantCondition" msg="Redundant condition: If x &gt; 11 the condition x &gt; 10 is always true. (since Cppcheck 1.54)" verbose="Redundant condition: If x &gt; 11 the condition x &gt; 10 is always true." />
<error id="redundantCopy" msg="Buffer &apos;var&apos; is being written before its old content has been used. (since Cppcheck 1.57)" verbose="Buffer &apos;var&apos; is being written before its old content has been used." />
<error id="redundantCopyInSwitch" msg="Buffer &apos;var&apos; is being written before its old content has been used. &apos;break;&apos; missing? (since Cppcheck 1.57)" verbose="Buffer &apos;var&apos; is being written before its old content has been used. &apos;break;&apos; missing?" />
<error id="redundantCopyLocalConst" msg="Use const reference for &apos;varname&apos; to avoid unnecessary data copying. (since Cppcheck 1.56)" verbose="The const variable &apos;varname&apos; is assigned a copy of the data. You can avoid the unnecessary data copying by converting &apos;varname&apos; to const reference." />
<error id="redundantIfRemove" msg="Redundant checking of STL container element existence before removing it. (since Cppcheck 1.52)" verbose="Redundant checking of STL container element existence before removing it. It is safe to call the remove method on a non-existing element." />
<error id="redundantOperationInSwitch" msg="Redundant operation on &apos;varname&apos; in switch. (Cppcheck 1.56)" verbose="Redundant operation on &apos;varname&apos; in switch." />
<error id="redundantPointerOp" msg="Redundant pointer operation on varname - it&apos;s already a pointer. (since Cppcheck 1.69)" verbose="Redundant pointer operation on varname - it&apos;s already a pointer." />
<error id="resourceLeak" msg="Resource leak: varname (since Cppcheck 1.52)" verbose="Resource leak: varname" />
<error id="returnAddressOfAutoVariable" msg="Address of an auto-variable returned. (since Cppcheck 1.52)" verbose="Address of an auto-variable returned." />
<error id="returnAddressOfFunctionParameter" msg="Address of function parameter &apos;parameter&apos; returned. (since Cppcheck 1.52)" verbose="Address of the function parameter &apos;parameter&apos; becomes invalid after the function exits because function parameters are stored on the stack which is freed when the function exits. Thus the returned value is invalid." />
<error id="returnAutocstr" msg="Returning pointer to auto variable (Cppcheck 1.52-1.53)" verbose="Returning pointer to auto variable" />
<error id="returnLocalVariable" msg="Pointer to local array variable returned. (since Cppcheck 1.52)" verbose="Pointer to local array variable returned." />
<error id="returnReference" msg="Reference to auto variable returned. (since Cppcheck 1.52)" verbose="Reference to auto variable returned." />
<error id="returnTempPointer" msg="Pointer to temporary returned. (Cppcheck 1.52-1.56)" verbose="Pointer to temporary returned." />
<error id="returnTempReference" msg="Reference to temporary returned. (since Cppcheck 1.52)" verbose="Reference to temporary returned." />
<error id="secondAlwaysTrueFalseWhenFirstTrue" msg="when first comparison is true, the 2nd comparison is always true (Cppcheck 1.52-1.53)" verbose="when first comparison is true, the 2nd comparison is always true" />
<error id="seekOnAppendedFile" msg="Repositioning operation performed on a file opened in append mode has no effect. (since Cppcheck 1.65)" verbose="Repositioning operation performed on a file opened in append mode has no effect." />
<error SonarQube="S1656"
    id="selfAssignment" msg="Redundant assignment of &apos;varname&apos; to itself. (since Cppcheck 1.52)" verbose="Redundant assignment of &apos;varname&apos; to itself." />
<error id="selfInitialization" msg="Member variable &apos;var&apos; is initialized by itself. (since Cppcheck 1.67)" verbose="Member variable &apos;var&apos; is initialized by itself." />
<error id="shiftNegative" msg="Shifting by a negative value is undefined behaviour (since Cppcheck 1.56)" verbose="Shifting by a negative value is undefined behaviour" />
<error id="shiftTooManyBits" msg="Shifting 32-bit value by 64 bits is undefined behaviour (since Cppcheck 1.67)" verbose="Shifting 32-bit value by 64 bits is undefined behaviour" />
<error id="signConversion" msg="Suspicious code: sign conversion of var in calculation, even though var can have a negative value (since Cppcheck 1.67)" verbose="Suspicious code: sign conversion of var in calculation, even though var can have a negative value" />
<error id="sizeArgumentAsChar" msg="The size argument is given as a char constant. (since Cppcheck 1.69)" verbose="The size argument is given as a char constant." />
<error SonarQube="SideEffectInSizeOf"
    id="sizeofCalculation" msg="Found calculation inside sizeof(). (since Cppcheck 1.52)" verbose="Found calculation inside sizeof()." />
<error SonarQube="S2665"
    id="sizeofDereferencedVoidPointer" msg="&apos;*varname&apos; is of type &apos;void&apos;, the behaviour of &apos;sizeof(void)&apos; is not covered by the ISO C standard. (since Cppcheck 1.61)" verbose="&apos;*varname&apos; is of type &apos;void&apos;, the behaviour of &apos;sizeof(void)&apos; is not covered by the ISO C standard. A value for &apos;sizeof(void)&apos; is defined only as part of a GNU C extension, which defines &apos;sizeof(void)&apos; to be 1." />
<error id="sizeofDivisionMemfunc" msg="Division by result of sizeof(). memset() expects a size in bytes, did you intend to multiply instead? (since Cppcheck 1.67)" verbose="Division by result of sizeof(). memset() expects a size in bytes, did you intend to multiply instead?" />
<error SonarQube="S2665"
    id="sizeofVoid" msg="Behaviour of &apos;sizeof(void)&apos; is not covered by the ISO C standard. (since Cppcheck 1.61)" verbose="Behaviour of &apos;sizeof(void)&apos; is not covered by the ISO C standard. A value for &apos;sizeof(void)&apos; is defined only as part of a GNU C extension, which defines &apos;sizeof(void)&apos; to be 1." />
<error SonarQube="SizeofSizeof"
    id="sizeofsizeof" msg="Calling &apos;sizeof&apos; on &apos;sizeof&apos;. (since Cppcheck 1.52)" verbose="Calling sizeof for &apos;sizeof looks like a suspicious code and most likely there should be just one &apos;sizeof&apos;. The current code is equivalent to &apos;sizeof(size_t)&apos;" />
<error id="sizeofwithnumericparameter" msg="Suspicious usage of &apos;sizeof&apos; with a numeric constant as parameter. (since Cppcheck 1.52)" verbose="It is unusual to use a constant value with sizeof. For example, &apos;sizeof(10)&apos; returns 4 (in 32-bit systems) or 8 (in 64-bit systems) instead of 10. &apos;sizeof(&apos;A&apos;)&apos; and &apos;sizeof(char)&apos; can return different results." />
<error id="sizeofwithsilentarraypointer" msg="Using &apos;sizeof&apos; on array given as function argument returns size of a pointer. (since Cppcheck 1.52)" verbose="Using &apos;sizeof&apos; for array given as function argument returns the size of a pointer. It does not return the size of the whole array in bytes as might be expected. For example, this code:\012     int f(char a[100]) {\012         return sizeof(a);\012     }\012returns 4 (in 32-bit systems) or 8 (in 64-bit systems) instead of 100 (the size of the array in bytes)." />
<error id="sprintfOverlappingData" msg="Undefined behavior: Variable &apos;varname&apos; is used as parameter and destination in s[n]printf(). (since Cppcheck 1.52)" verbose="The variable &apos;varname&apos; is used both as a parameter and as destination in s[n]printf(). The origin and destination buffers overlap. Quote from glibc (C-library) documentation (http://www.gnu.org/software/libc/manual/html_mono/libc.html#Formatted-Output-Functions): &quot;If copying takes place between objects that overlap as a result of a call to sprintf() or snprintf(), the results are undefined.&quot;" />
<error id="staticStringCompare" msg="Unnecessary comparison of static strings. (since Cppcheck 1.54)" verbose="The compared strings, &apos;str1&apos; and &apos;str2&apos;, are always unequal. Therefore the comparison is unnecessary and looks suspicious." />
<error id="stlBoundaries" msg="Dangerous iterator comparison using operator&lt; on &apos;std::container&apos;. (since Cppcheck 1.59)" verbose="Iterator of container &apos;std::container&apos; compared with operator&lt;. This is dangerous since the order of items in the container is not guaranteed. One should use operator!= instead to compare iterators." />
<error id="stlBoundries" msg="Dangerous iterator comparison using operator&lt; on &apos;std::container&apos;. (Cppcheck 1.52-1.58)" verbose="Iterator of container &apos;std::container&apos; compared with operator&lt;. This is dangerous since the order of items in the container is not guaranteed. One should use operator!= instead to compare iterators." />
<error id="stlIfFind" msg="Suspicious condition. The result of find() is an iterator, but it is not properly checked. (since Cppcheck 1.52)" verbose="Suspicious condition. The result of find() is an iterator, but it is not properly checked." />
<error id="stlIfStrFind" msg="Inefficient usage of string::find() in condition; string::compare() would be faster. (since Cppcheck 1.52)" verbose="Either inefficient or wrong usage of string::find(). string::compare() will be faster if string::find&apos;s result is compared with 0, because it will not scan the whole string. If your intention is to check that there are no findings in the string, you should compare with std::string::npos." />
<error id="stlOutOfBounds" msg="When i==foo.size(), foo[i] is out of bounds. (since Cppcheck 1.52)" verbose="When i==foo.size(), foo[i] is out of bounds." />
<error id="stlSize" msg="Possible inefficient checking for &apos;list&apos; emptiness. (since Cppcheck 1.52)" verbose="Checking for &apos;list&apos; emptiness might be inefficient. Using list.empty() instead of list.size() can be faster. list.size() can take linear time but list.empty() is guaranteed to take constant time." />
<error id="stlcstr" msg="Dangerous usage of c_str(). The value returned by c_str() is invalid after this call. (since Cppcheck 1.52)" verbose="Dangerous usage of c_str(). The c_str() return value is only valid until its string is deleted." />
<error id="stlcstrParam" msg="Passing the result of c_str() to a function that takes std::string as argument no. 0 is slow and redundant. (since Cppcheck 1.54)" verbose="The conversion from const char* as returned by c_str() to std::string creates an unnecessary string copy. Solve that by directly passing the string." />
<error id="stlcstrReturn" msg="Returning the result of c_str() in a function that returns std::string is slow and redundant. (since Cppcheck 1.54)" verbose="The conversion from const char* as returned by c_str() to std::string creates an unnecessary string copy. Solve that by directly returning the string." />
<error id="strPlusChar" msg="Unusual pointer arithmetic. A value of type &apos;char&apos; is added to a string literal. (since Cppcheck 1.52)" verbose="Unusual pointer arithmetic. A value of type &apos;char&apos; is added to a string literal." />
<error id="stringCompare" msg="Comparison of identical string variables. (since Cppcheck 1.52)" verbose="The compared strings, &apos;varname1&apos; and &apos;varname2&apos;, are identical. This could be a logic bug." />
<error id="stringLiteralWrite" msg="Modifying string literal directly or indirectly is undefined behaviour. (since Cppcheck 1.70)" verbose="Modifying string literal directly or indirectly is undefined behaviour." />
<error id="strncatUsage" msg="Dangerous usage of strncat - 3rd parameter is the maximum number of characters to append. (since Cppcheck 1.69)" verbose="At most, strncat appends the 3rd parameter&apos;s amount of characters and adds a terminating null byte.\012The safe way to use strncat is to subtract one from the remaining space in the buffer and use it as 3rd parameter.Source: http://www.cplusplus.com/reference/cstring/strncat/\012Source: http://www.opensource.apple.com/source/Libc/Libc-167/gen.subproj/i386.subproj/strncat.c" />
<error id="suspiciousCase" msg="Found suspicious case label in switch(). Operator &apos;||&apos; probably doesn&apos;t work as intended. (since Cppcheck 1.58)" verbose="Using an operator like &apos;||&apos; in a case label is suspicious. Did you intend to use a bitwise operator, multiple case labels or if/else instead?" />
<error SonarQube="S905"
    id="suspiciousEqualityComparison" msg="Found suspicious equality comparison. Did you intend to assign a value instead? (since Cppcheck 1.59)" verbose="Found suspicious equality comparison. Did you intend to assign a value instead?" />
<error id="suspiciousSemicolon" msg="Suspicious use of ; at the end of &apos;&apos; statement. (since Cppcheck 1.54)" verbose="Suspicious use of ; at the end of &apos;&apos; statement." />
<error SonarQube="NonEmptyCaseWithoutBreak"
    id="switchCaseFallThrough" msg="Switch falls through case without comment. &apos;break;&apos; missing? (since Cppcheck 1.52)" verbose="Switch falls through case without comment. &apos;break;&apos; missing?" />
<error id="syntaxError" msg="Invalid number of character ( ) when these macros are defined: &apos;&apos;. (Cppcheck 1.52-1.64)" verbose="Invalid number of character ( ) when these macros are defined: &apos;&apos;." />
<error id="terminateStrncpy" msg="The buffer &apos;buffer&apos; may not be null-terminated after the call to strncpy(). (since Cppcheck 1.52)" verbose="If the source string&apos;s size fits or exceeds the given size, strncpy() does not add a zero at the end of the buffer. This causes bugs later in the code if the code assumes buffer is null-terminated." />
<error id="thisSubtraction" msg="Suspicious pointer subtraction. Did you intend to write &apos;-&gt;&apos;? (since Cppcheck 1.52)" verbose="Suspicious pointer subtraction. Did you intend to write &apos;-&gt;&apos;?" />
<error id="throwInNoexceptFunction" msg="Exception thrown in function declared not to throw exceptions. (since Cppcheck 1.69)" verbose="Exception thrown in function declared not to throw exceptions." />
<error id="tooBigSleepTime" msg="The argument of usleep must be less than 1000000. (Cppcheck 1.59-1.62)" verbose="The argument of usleep must be less than 1000000, but dimension is provided." />
<error id="toomanyconfigs" msg="Too many #ifdef configurations - cppcheck only checks 12 configurations. Use --force to check all configurations. For more details, use --enable=information. (since Cppcheck 1.58)" verbose="The checking of the file will be interrupted because there are too many #ifdef configurations. Checking of all #ifdef configurations can be forced by --force command line option or from GUI preferences. However that may increase the checking time. For more details, use --enable=information." />
<error id="truncLongCastAssignment" msg="int result is assigned to long variable. If the variable is long to avoid loss of information, then you have loss of information. (since Cppcheck 1.70)" verbose="int result is assigned to long variable. If the variable is long to avoid loss of information, then there is loss of information. To avoid loss of information you must cast a calculation operand to long, for example &apos;l = a * b;&apos; =&gt; &apos;l = (long)a * b;&apos;." />
<error id="truncLongCastReturn" msg="int result is returned as long value. If the return value is long to avoid loss of information, then you have loss of information. (since Cppcheck 1.70)" verbose="int result is returned as long value. If the return value is long to avoid loss of information, then there is loss of information. To avoid loss of information you must cast a calculation operand to long, for example &apos;return a*b;&apos; =&gt; &apos;return (long)a*b&apos;." />
<error id="udivError" msg="Unsigned division. The result will be wrong. (Cppcheck 1.52-1.66)" verbose="Unsigned division. The result will be wrong." />
<error id="unassignedVariable" msg="Variable &apos;varname&apos; is not assigned a value. (since Cppcheck 1.52)" verbose="Variable &apos;varname&apos; is not assigned a value." />
<error id="unhandledExceptionSpecification" msg="Unhandled exception specification when calling function foo(). (since Cppcheck 1.65)" verbose="Unhandled exception specification when calling function foo(). Either use a try/catch around the function call, or add a exception specification for funcname() also." />
<error id="uninitMemberVar" msg="Member variable &apos;classname::varname&apos; is not initialized in the constructor. (since Cppcheck 1.54)" verbose="Member variable &apos;classname::varname&apos; is not initialized in the constructor." />
<error id="uninitStructMember" msg="Uninitialized struct member: a.b (since Cppcheck 1.59)" verbose="Uninitialized struct member: a.b" />
<error id="uninitVar" msg="Member variable &apos;classname::varname&apos; is not initialized in the constructor. (Cppcheck 1.52-1.53)" verbose="Member variable &apos;classname::varname&apos; is not initialized in the constructor." />
<error id="uninitdata" msg="Memory is allocated but not initialized: varname (since Cppcheck 1.52)" verbose="Memory is allocated but not initialized: varname" />
<error id="uninitstring" msg="Dangerous usage of &apos;varname&apos; (strncpy doesn&apos;t always null-terminate it). (since Cppcheck 1.52)" verbose="Dangerous usage of &apos;varname&apos; (strncpy doesn&apos;t always null-terminate it)." />
<error id="uninitvar" msg="Uninitialized variable: varname (since Cppcheck 1.52)" verbose="Uninitialized variable: varname" />
<error SonarQube="S3231"
    id="unnecessaryForwardDeclaration" msg="The variable &apos;name&apos; forward declaration is unnecessary. Type variable is already declared earlier. (since Cppcheck 1.52)" verbose="The variable &apos;name&apos; forward declaration is unnecessary. Type variable is already declared earlier." />
<error id="unnecessaryQualification" msg="The extra qualification &apos;type&apos; is unnecessary and is considered an error by many compilers. (Cppcheck 1.52-1.70)" verbose="The extra qualification &apos;type&apos; is unnecessary and is considered an error by many compilers." />
<error id="unpreciseMathCall" msg="Expression &apos;1 - erf(x)&apos; can be replaced by &apos;erfc(x)&apos; to avoid loss of precision. (since Cppcheck 1.67)" verbose="Expression &apos;1 - erf(x)&apos; can be replaced by &apos;erfc(x)&apos; to avoid loss of precision." />
<error SonarQube="S1763"
    id="unreachableCode" msg="Statements following return, break, continue, goto or throw will never be executed. (since Cppcheck 1.52)" verbose="Statements following return, break, continue, goto or throw will never be executed." />
<error id="unreadVariable" msg="Variable &apos;varname&apos; is assigned a value that is never used. (since Cppcheck 1.52)" verbose="Variable &apos;varname&apos; is assigned a value that is never used." />
<error id="unsafeClassCanLeak" msg="Class &apos;class&apos; is unsafe, &apos;class::varname&apos; can leak by wrong usage. (since Cppcheck 1.57)" verbose="The class &apos;class&apos; is unsafe, wrong usage can cause memory/resource leaks for &apos;class::varname&apos;. This can for instance be fixed by adding proper cleanup in the destructor." />
<error SonarQube="S1768"
    id="unsignedLessThanZero" msg="Checking if unsigned variable &apos;varname&apos; is less than zero. (since Cppcheck 1.52)" verbose="The unsigned variable &apos;varname&apos; will never be negative so it is either pointless or an error to check if it is." />
<error SonarQube="S1768"
    id="unsignedPositive" msg="Unsigned variable &apos;varname&apos; can&apos;t be negative so it is unnecessary to test it. (since Cppcheck 1.52)" verbose="Unsigned variable &apos;varname&apos; can&apos;t be negative so it is unnecessary to test it." />
<error id="unusedAllocatedMemory" msg="Variable &apos;varname&apos; is allocated memory that is never used. (since Cppcheck 1.52)" verbose="Variable &apos;varname&apos; is allocated memory that is never used." />
<error id="unusedFunction" msg="The function &apos;funcName&apos; is never used. (since Cppcheck 1.52)" verbose="The function &apos;funcName&apos; is never used." />
<error SonarQube="S1065"
    id="unusedLabel" msg="Label &apos;&apos; is not used. (since Cppcheck 1.70)" verbose="Label &apos;&apos; is not used." />
<error id="unusedPrivateFunction" msg="Unused private function: &apos;classname::funcname&apos; (since Cppcheck 1.52)" verbose="Unused private function: &apos;classname::funcname&apos;" />
<error SonarQube="S1481"
    id="unusedScopedObject" msg="Instance of &apos;varname&apos; object is destroyed immediately. (since Cppcheck 1.52)" verbose="Instance of &apos;varname&apos; object is destroyed immediately." />
<error id="unusedStructMember" msg="struct member &apos;structname::variable&apos; is never used. (since Cppcheck 1.52)" verbose="struct member &apos;structname::variable&apos; is never used." />
<error SonarQube="S1481"
    id="unusedVariable" msg="Unused variable: varname (since Cppcheck 1.52)" verbose="Unused variable: varname" />
<error id="useAutoPointerArray" msg="Object pointed by an &apos;auto_ptr&apos; is destroyed using operator &apos;delete&apos;. You should not use &apos;auto_ptr&apos; for pointers obtained with operator &apos;new[]&apos;. (since Cppcheck 1.52)" verbose="Object pointed by an &apos;auto_ptr&apos; is destroyed using operator &apos;delete&apos;. This means that you should only use &apos;auto_ptr&apos; for pointers obtained with operator &apos;new&apos;. This excludes arrays, which are allocated by operator &apos;new[]&apos; and must be deallocated by operator &apos;delete[]&apos;." />
<error id="useAutoPointerContainer" msg="You can randomly lose access to pointers if you store &apos;auto_ptr&apos; pointers in an STL container. (since Cppcheck 1.52)" verbose="An element of container must be able to be copied but &apos;auto_ptr&apos; does not fulfill this requirement. You should consider to use &apos;shared_ptr&apos; or &apos;unique_ptr&apos;. It is suitable for use in containers, because they no longer copy their values, they move them." />
<error id="useAutoPointerCopy" msg="Copying &apos;auto_ptr&apos; pointer to another does not create two equal objects since one has lost its ownership of the pointer. (since Cppcheck 1.52)" verbose="&apos;std::auto_ptr&apos; has semantics of strict ownership, meaning that the &apos;auto_ptr&apos; instance is the sole entity responsible for the object&apos;s lifetime. If an &apos;auto_ptr&apos; is copied, the source looses the reference." />
<error id="useAutoPointerMalloc" msg="Object pointed by an &apos;auto_ptr&apos; is destroyed using operator &apos;delete&apos;. You should not use &apos;auto_ptr&apos; for pointers obtained with function &apos;malloc&apos;. (since Cppcheck 1.69)" verbose="Object pointed by an &apos;auto_ptr&apos; is destroyed using operator &apos;delete&apos;. You should not use &apos;auto_ptr&apos; for pointers obtained with function &apos;malloc&apos;. This means that you should only use &apos;auto_ptr&apos; for pointers obtained with operator &apos;new&apos;. This excludes use C library allocation functions (for example &apos;malloc&apos;), which must be deallocated by the appropriate C library function." />
<error id="useClosedFile" msg="Used file that is not opened. (since Cppcheck 1.55)" verbose="Used file that is not opened." />
<error SonarQube="S3230:cpp"
    id="useInitializationList" msg="Variable &apos;variable&apos; is assigned in constructor body. Consider performing initialization in initialization list. (since Cppcheck 1.55)" verbose="When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don&apos;t explicitly write them to the initialization list. You could avoid assigning &apos;variable&apos; a value by passing the value to the constructor in the initialization list." />
<error id="uselessAssignmentArg" msg="Assignment of function parameter has no effect outside the function. (since Cppcheck 1.67)" verbose="Assignment of function parameter has no effect outside the function." />
<error id="uselessAssignmentPtrArg" msg="Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? (since Cppcheck 1.59)" verbose="Assignment of function parameter has no effect outside the function. Did you forget dereferencing it?" />
<error id="uselessCallsCompare" msg="It is inefficient to call &apos;str.find(str)&apos; as it always returns 0. (since Cppcheck 1.52)" verbose="&apos;std::string::find()&apos; returns zero when given itself as parameter (str.find(str)). As it is currently the code is inefficient. It is possible either the string searched (&apos;str&apos;) or searched for (&apos;str&apos;) is wrong." />
<error id="uselessCallsEmpty" msg="Ineffective call of function &apos;empty()&apos;. Did you intend to call &apos;clear()&apos; instead? (since Cppcheck 1.56)" verbose="Ineffective call of function &apos;empty()&apos;. Did you intend to call &apos;clear()&apos; instead?" />
<error id="uselessCallsRemove" msg="Return value of std::remove() ignored. Elements remain in container. (since Cppcheck 1.56)" verbose="The return value of std::remove() is ignored. This function returns an iterator to the end of the range containing those elements that should be kept. Elements past new end remain valid but with unspecified values. Use the erase method of the container to delete them." />
<error id="uselessCallsSubstr" msg="Ineffective call of function &apos;substr&apos; because it returns a copy of the object. Use operator= instead. (since Cppcheck 1.52)" verbose="Ineffective call of function &apos;substr&apos; because it returns a copy of the object. Use operator= instead." />
<error id="uselessCallsSwap" msg="It is inefficient to swap a object with itself by calling &apos;str.swap(str)&apos; (since Cppcheck 1.52)" verbose="The &apos;swap()&apos; function has no logical effect when given itself as parameter (str.swap(str)). As it is currently the code is inefficient. Is the object or the parameter wrong here?" />
<error id="va_end_missing" msg="va_list &apos;vl&apos; was opened but not closed by va_end(). (since Cppcheck 1.67)" verbose="va_list &apos;vl&apos; was opened but not closed by va_end()." />
<error id="va_list_usedBeforeStarted" msg="va_list &apos;vl&apos; used before va_start() was called. (since Cppcheck 1.67)" verbose="va_list &apos;vl&apos; used before va_start() was called." />
<error id="va_start_referencePassed" msg="Using reference &apos;arg1&apos; as parameter for va_start() results in undefined behaviour. (since Cppcheck 1.67)" verbose="Using reference &apos;arg1&apos; as parameter for va_start() results in undefined behaviour." />
<error id="va_start_subsequentCalls" msg="va_start() or va_copy() called subsequently on &apos;vl&apos; without va_end() in between. (since Cppcheck 1.67)" verbose="va_start() or va_copy() called subsequently on &apos;vl&apos; without va_end() in between." />
<error id="va_start_wrongParameter" msg="&apos;arg1&apos; given to va_start() is not last named argument of the function. Did you intend to pass &apos;arg2&apos;? (since Cppcheck 1.67)" verbose="&apos;arg1&apos; given to va_start() is not last named argument of the function. Did you intend to pass &apos;arg2&apos;?" />
<error id="varFuncNullUB" msg="Passing NULL after the last typed argument to a variadic function leads to undefined behaviour. (since Cppcheck 1.59)" verbose="Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.\012The C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.\012The value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.\012In practice on common architectures, this will cause real crashes if sizeof(int) != sizeof(void*), and NULL is defined to 0 or any other null pointer constant that promotes to int.\012To reproduce you might be able to use this little code example on 64bit platforms. If the output includes &quot;ERROR&quot;, the sentinel had only 4 out of 8 bytes initialized to zero and was not detected as the final argument to stop argument processing via va_arg(). Changing the 0 to (void*)0 or 0L will make the &quot;ERROR&quot; output go away.\012#include &lt;stdarg.h&gt;\012#include &lt;stdio.h&gt;\012\012void f(char *s, ...) {\012    va_list ap;\012    va_start(ap,s);\012    for (;;) {\012        char *p = va_arg(ap,char*);\012        printf(&quot;%018p, %s\n&quot;, p, (long)p &amp; 255 ? p : &quot;&quot;);\012        if(!p) break;\012    }\012    va_end(ap);\012}\012\012void g() {\012    char *s2 = &quot;x&quot;;\012    char *s3 = &quot;ERROR&quot;;\012\012    // changing 0 to 0L for the 7th argument (which is intended to act as sentinel) makes the error go away on x86_64\012    f(&quot;first&quot;, s2, s2, s2, s2, s2, 0, s3, (char*)0);\012}\012\012void h() {\012    int i;\012    volatile unsigned char a[1000];\012    for (i = 0; i&lt;sizeof(a); i++)\012        a[i] = -1;\012}\012\012int main() {\012    h();\012    g();\012    return 0;\012}" />
<error id="variableHidingEnum" msg="variable &apos;name&apos; hides enumerator with same name (since Cppcheck 1.52)" verbose="variable &apos;name&apos; hides enumerator with same name" />
<error id="variableHidingTypedef" msg="The variable &apos;name&apos; hides a typedef with the same name. (since Cppcheck 1.54)" verbose="The variable &apos;name&apos; hides a typedef with the same name." />
<error id="variableScope" msg="The scope of the variable &apos;varname&apos; can be reduced. (since Cppcheck 1.52)" verbose="The scope of the variable &apos;varname&apos; can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for &apos;i&apos; can be reduced:\012void f(int x)\012{\012    int i = 0;\012    if (x) {\012        // it&apos;s safe to move &apos;int i = 0;&apos; here\012        for (int n = 0; n &lt; 10; ++n) {\012            // it is possible but not safe to move &apos;int i = 0;&apos; here\012            do_something(&amp;i);\012        }\012    }\012}\012When you see this message it is always safe to reduce the variable scope 1 level." />
<error SonarQube="S1235:cpp"
    id="virtualDestructor" msg="Class &apos;Base&apos; which is inherited by class &apos;Derived&apos; does not have a virtual destructor. (since Cppcheck 1.54)" verbose="Class &apos;Base&apos; which is inherited by class &apos;Derived&apos; does not have a virtual destructor. If you destroy instances of the derived class by deleting a pointer that points to the base class, only the destructor of the base class is executed. Thus, dynamic memory that is managed by the derived class could leak. This can be avoided by adding a virtual destructor to the base class." />
<error id="writeOutsideBufferSize" msg="Writing 1 bytes outside buffer size. (Cppcheck 1.59-1.68)" verbose="The number of bytes to write (3 bytes) are bigger than the source buffer (2 bytes). Please check the second and the third parameter of the function &apos;write&apos;." />
<error id="writeReadOnlyFile" msg="Write operation on a file that was opened only for reading. (since Cppcheck 1.55)" verbose="Write operation on a file that was opened only for reading." />
<error id="wrongPipeParameterSize" msg="Buffer &apos;varname&apos; must have size of 2 integers if used as parameter of pipe(). (since Cppcheck 1.59)" verbose="The pipe()/pipe2() system command takes an argument, which is an array of exactly two integers.\012The variable &apos;varname&apos; is an array of size dimension, which does not match." />
<error id="wrongPrintfScanfArgNum" msg="printf format string requires 3 parameters but only 2 are given. (since Cppcheck 1.53)" verbose="printf format string requires 3 parameters but only 2 are given." />
<error id="wrongPrintfScanfArgs" msg="printf format string has 3 parameters but only 2 are given (Cppcheck 1.52)" verbose="printf format string has 3 parameters but only 2 are given" />
<error id="wrongPrintfScanfParameterPositionError" msg="printf: referencing parameter 2 while 1 arguments given (since Cppcheck 1.61)" verbose="printf: referencing parameter 2 while 1 arguments given" />
<error id="wrongcctypecall" msg="Passing value value to funname() causes undefined behavior which may lead to a crash. (Cppcheck 1.52-1.62)" verbose="Passing value value to funname() causes undefined behavior which may lead to a crash." />
<error id="wrongmathcall" msg="Passing value &apos;#&apos; to #() leads to implementation-defined result. (since Cppcheck 1.52)" verbose="Passing value &apos;#&apos; to #() leads to implementation-defined result." />
<error id="zerodiv" msg="Division by zero. (since Cppcheck 1.52)" verbose="Division by zero." />
<error id="zerodivcond" msg="Either the condition is redundant or there is division by zero at line 0. (since Cppcheck 1.62)" verbose="Either the condition is redundant or there is division by zero at line 0." />
</errors>
</results>
